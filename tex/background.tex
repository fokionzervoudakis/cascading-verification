\section{Background}
\label{sec:Background}

\noindent The research problem outlined in the previous section cannot be addressed with a single technology. Our solution was to develop a method that integrates OWL+SWRL, Prolog and DTMC and PCTL\@. OWL was chosen because it is an established knowledge representation formalism, and the ontology specification language recommended by the W3C~\cite{Horrocks_2011}. OWL limitations motivate several contending extensions including SWRL, CARIN, $\mathcal{AL}$-log, DL-safe rules, $\mathcal{DL}$+log, and many others~\cite{Motik_2006}. Hybrid knowledge representation systems that integrate OWL+SWRL and Prolog have also been proposed~\cite{Sensoy_2011,Matzner_2007,Papadakis_2011,Samuel_2008,Lukacsy_2009a,Almendros_Jimenez_2011,Elenius_2012}. In the interest of space, we cannot offer a comprehensive review of all these formalisms. We chose to address OWL limitations with SWRL and Prolog; the former is an OWL extension approved by the W3C, while the latter is one of the most prominent logic-based knowledge representation languages.

Probabilistic model checking is supported by various software tools including ProbVerus and FMur$\varphi$, which analyze DTMC models; ETMCC and MRMC (the successor of ETMCC), which analyze DTMC and CTMC models; and LiQuor and Rapture, which analyze \emph{Markov decision process} (MDP) models~\cite{Baier_2008}. But PRISM is, in our opinion, preferable because it supports both model types, thereby extending the potential of our method and prototype. PRISM also supports PCTL, a formalism that can express a large class of properties in an elegant manner.

We proceed to elaborate the technologies that constitute cascading verification.

\subsection{OWL+SWRL and Prolog}

\noindent \emph{Description logics} (DLs) are a family of knowledge representation languages based on \emph{first-order logic} (FOL) that can be used to construct logically valid knowledge bases. DLs describe a domain in terms of \emph{concepts} or \emph{classes} (specified as axioms in a TBox), \emph{individuals} (specified as assertions in an ABox) and \emph{properties} or \emph{roles}~\cite{Horrocks_2011}. DL concepts and individuals are roughly comparable to classes and objects, respectively, in object-oriented programming, while roles are comparable to UML associations. DLs support inferences that deduce the logical implications of ontological axioms with respect to concept \emph{satisfiability}, \emph{subsumption}, \emph{equivalence} and \emph{disjointness}~\cite{Baader_2005}.

OWL is an ontology specification language based on the modern DL $\mathcal{SHOIN(\mathbf{D})}$~\cite{Horrocks_2011}. The OWL language structures, and thereby supports the automated processing of, formalized knowledge. But OWL is constrained by the expressive and reasoning limitations inherent in $\mathcal{SHOIN(\mathbf{D})}$. For example, OWL can be used to model object relations that form tree-like patterns, but not the triangular relationship that exists between a child, the child's father, and the father's brother~\cite{Motik_2006}; nor the self-referential relationship that references an individual to itself~\cite{Krotzsch_2011}. SWRL addresses some of these limitations by extending OWL with Horn-like rules~\cite{Horrocks_2004}. But OWL+SWRL cannot reason effectively with negation~\cite{Motik_2006,McGrath_2008}. Problems that are intractable in OWL+SWRL can be addressed with the programming language Prolog~\cite{Motik_2006,Volz_2003}.

Prolog is based on a FOL subset, which is expressed with first-order Horn clauses comprising facts, queries and rules. Unlike OWL+SWRL, Prolog can reason effectively with ne\-gation. But Prolog is not without limitations: OWL can be translated into formulas of a general FOL subset, but this subset overlaps only partially with the FOL subset underpinning Prolog. Consequently, some OWL primitives cannot be expressed efficiently in Prolog. For example, Prolog does not provide an equivalence predicate; Prolog's native syntax cannot encode the OWL primitives \texttt{disjointWith} and \texttt{differentIndividualFrom}, which denote concept and individual disjointness, respectively; and Prolog cannot encode the OWL primitive \texttt{oneOf}, which defines a concept by enumerating all individuals belonging to that concept.

This paper does not propose a definitive or optimal OWL-LP integration framework. Nor do we attempt to take sides in the ongoing debate regarding OWL-LP integration~\cite{Motik_2006}. Our exclusive objective is to support domain-specific probabilistic model checking by combining well established logic systems~\cite{Motik_2006,Costa_2012}. We propose to achieve this objective via \emph{loose} (rather than \emph{full}) integration, whereby DL and LP components are connected through a minimal interface~\cite{Greco_2010}.

\subsection{Probabilistic Model Checking}

\noindent Probabilistic model checking is a method for verifying the behavioral properties of systems affected by stochastic processes~\cite{Baier_2008,Kwiatkowska_2012}. In order to model these processes, which may include message delays, failure rates and other phenomena, finite-state transition systems are enriched with probabilities. \emph{Markov chains} are transition systems where the successor of each state is chosen probabilistically and independently of preceding events (i.e., Markov chains are memoryless). DTMCs are Markov chains that represent time in discrete time-steps. A DTMC can be formalized as a tuple $\mathcal{M} = (S, \mathbf{P}, \iota_{init}, AP, L)$ where $S$ is a countable set of states; $\mathbf{P}: S \times S \rightarrow [0, 1]$ is the transition probability function, such that for all states \emph{s}: $\sum_{s' \in S} \mathbf{P}(s, s') = 1$; $\iota_{init}: S \rightarrow [0, 1]$ is the initial state distribution, such that $\sum_{s' \in S} \iota_{init}(s) = 1$; and $L: S \rightarrow 2^{AP}$ is a labeling function that maps each state to a subset of $AP$, a set of atomic propositions that abstract key characteristics from modeled systems.

Probabilistic model checking can be used to verify both quantitative and qualitative DTMC properties. The former constrain probabilities to specific thresholds, while the latter associate desirable and undesirable behavior with probabilities of one and zero, respectively. PCTL is an extension of the branching-time \emph{computation tree logic} (CTL), and a prominent formalism for expressing probabilistic properties. PCTL supports the probabilistic operator $\mathbb{P}_{J}(\varphi)$, where $\varphi$ specifies a constraint over the set of paths that constitute a Markov chain, and $J$ specifies a closed interval between one and zero that bounds the probability of satisfying $\varphi$.

\subsection{UAV Missions}

\noindent UAVs, or \emph{uninhabited aerial systems} (UASs), are aircraft capable of either autonomous or remote controlled flight. Primarily oriented toward (dull, dirty, or dangerous) military missions, UAVs are increasingly relied upon to perform agricultural, scientific, industrial and law-enforcement tasks over civilian airspace~\cite{Rango_2010,Jimenez_Berni_2009,Heintz_2007}.

The UAV domain exhibits complexity at different levels of granularity. UAVs incorporate sophisticated payloads, multiple sensors and increasing computational power. These capabilities could, in time, enable UAV swarms to execute complex multi-task missions with reduced human supervision~\cite{Karaman_2008}. For any given mission, autonomous UAVs may be required to execute tasks synchronously and in real-time; with local, incomplete and/or noisy knowledge; and in the context of a dynamic environment~\cite{Tosic_2003}. These factors combine to form a complex stochastic state space that motivates the probabilistic verification of UAV mission plans.
